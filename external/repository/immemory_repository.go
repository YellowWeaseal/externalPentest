package repository

import (
	"externalPentest/external/model"
	"externalPentest/internal/types"
	nuclei "github.com/projectdiscovery/nuclei/v3/lib"
	"sync"
)

type InMemoryRepository struct {
	targetOptions       map[types.ScanName]model.RawTarget
	scanSettingsStorage map[types.ScanName]model.ScanSettings

	mu *sync.RWMutex
}

func NewInMemoryRepository() *InMemoryRepository {
	return &InMemoryRepository{
		targetOptions:    make(map[types.ScanName]model.RawTarget),
		templatesOptions: make(map[types.ScanName]model.RawTemplateOptions),
	}
}

func (r *InMemoryRepository) SetTarget(scanName types.ScanName, rawTarget model.RawTarget) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.targetOptions[scanName] = rawTarget
	return nil
}
func (r *InMemoryRepository) GetTarget(scanName types.ScanName) (model.RawTarget, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	return r.targetOptions[scanName], nil
}

/*func (r *InMemoryRepository) PutTemplatesOptions(scanName types.ScanName, rawOptions model.RawTemplateOptions) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.templatesOptions[scanName] = rawOptions
	return nil
}

func (r *InMemoryRepository) GetOptions(scanName types.ScanName) (model.RawNucleiOptions, error) {
	r.mu.Lock()
	defer r.mu.Unlock()

	r.nucleiOptions[scanName] = model.RawNucleiOptions{
		r.targetOptions[scanName].Target,
		r.targetOptions[scanName].ExcludeHosts,
		r.targetOptions[scanName].ScanAllIps,
		r.targetOptions[scanName].IpVersion,
		r.templatesOptions[scanName].NewTemplates,
		r.templatesOptions[scanName].AutomaticScan,
		r.templatesOptions[scanName].TemplatesList,
		r.templatesOptions[scanName].RateLimitPerSec,
		r.templatesOptions[scanName].RateLimitPerMinute,
		r.templatesOptions[scanName].BulkSize,
		r.templatesOptions[scanName].Concurrency,
		r.templatesOptions[scanName].HeadlessBulkSize,
		r.templatesOptions[scanName].HeadlessConcurrency,
	}
	return r.nucleiOptions[scanName], nil
}*/

func (r *InMemoryRepository) SetScannerSettings(settings model.RawScanSettings) error {
	tempSources := nuclei.TemplateSources{
		Templates:       nil, // template file/directory paths
		Workflows:       nil, // workflow file/directory paths
		RemoteTemplates: nil, // remote template urls
		RemoteWorkflows: nil, // remote workflow urls
		TrustedDomains:  nil, // trusted domains for remote templates/workflows
	}
	headLessOpt := nuclei.HeadlessOpts{
		PageTimeout:     settings.PageTimeout, // timeout for page load
		ShowBrowser:     false,
		HeadlessOptions: nil,
		UseChrome:       false,
	}

	netConf := nuclei.NetworkConfig{
		DisableMaxHostErr:     false, // Disable max host error optimization (Hosts are not skipped even if they are not responding)
		Interface:             "",    // Interface to use for network scan
		InternalResolversList: nil,   // Use a list of resolver
		LeaveDefaultPorts:     false, // Leave default ports for http/https
		MaxHostError:          0,     // Maximum number of host errors to allow before skipping that host
		Retries:               0,     // Number of retries
		SourceIP:              "",    // SourceIP sets custom source IP address for network requests
		SystemResolvers:       false, // Use system resolvers
		Timeout:               0,     // Timeout in seconds
		TrackError:            nil,   // Adds given errors to max host error watchlist
	}
	verbOpt := nuclei.VerbosityOptions{
		Verbose:       false, // show verbose output
		Silent:        false, // show only results
		Debug:         false, // show debug output
		DebugRequest:  false, // show request in debug output
		DebugResponse: false, // show response in debug output
		ShowVarDump:   false, // show variable dumps in output
	}
	statOpt := nuclei.StatsOptions{
		Interval:         0,
		JSON:             false,
		MetricServerPort: 0,
	}
	tempFilt := nuclei.TemplateFilters{
		Severity:             "",  // filter by severities (accepts CSV values of info, low, medium, high, critical)
		ExcludeSeverities:    "",  // filter by excluding severities (accepts CSV values of info, low, medium, high, critical)
		ProtocolTypes:        "",  // filter by protocol types
		ExcludeProtocolTypes: "",  // filter by excluding protocol types
		Authors:              nil, // fiter by author
		Tags:                 nil, // filter by tags present in template
		ExcludeTags:          nil, // filter by excluding tags present in template
		IncludeTags:          nil, // filter by including tags present in template
		IDs:                  nil, // filter by template IDs
		ExcludeIDs:           nil, // filter by excluding template IDs
		TemplateCondition:    nil, // DSL condition/ expression
	}
	model.ScanSettings{
		Target:      r.targetOptions[scanName],
		TempSources: tempSources,
		HeadLessOpt: &headLessOpt,
		InterOpts:   interOpts,
		NetConf:     netConf,
		VerbOpt:     verbOpt,
		StatOpt:     statOpt,
		TempFilter:  tempFilt,
	}
	return nil
}
func (r *InMemoryRepository) SetInteracthOpts() {
	interOpts := nuclei.InteractshOpts{
		ServerURL:           "",    // ServerURL is the URL of the interactsh server.
		Authorization:       "",    // Authorization is the Authorization header value
		CacheSize:           0,     // CacheSize is the numbers of requests to keep track of at a time. // Older items are discarded in LRU manner in favor of new requests.
		Eviction:            0,     // Eviction is the period of time after which to automatically discard // interaction requests.
		CooldownPeriod:      0,     // CooldownPeriod is additional time to wait for interactions after closing // of the poller.
		PollDuration:        0,     // PollDuration is the time to wait before each poll to the server for interactions.
		Output:              nil,   // Output is the output writer for nuclei
		IssuesClient:        nil,   // IssuesClient is a client for issue exporting
		Progress:            nil,   // Progress is the nuclei progress bar implementation.
		Debug:               false, // Debug specifies whether debugging output should be shown for interactsh-client
		DebugRequest:        false, // DebugRequest outputs interaction request
		DebugResponse:       false, // DebugResponse outputs interaction response
		DisableHttpFallback: false, // DisableHttpFallback controls http retry in case of https failure for server url
		NoInteractsh:        false, // NoInteractsh disables the engine
		NoColor:             false, // NoColor disables printing colors for matches
		StopAtFirstMatch:    false,
		HTTPClient:          nil,
	}
}
func (r *InMemoryRepository) GetScannerSettings(scanName types.ScanName) (model.ScanSettings, error) {

}
